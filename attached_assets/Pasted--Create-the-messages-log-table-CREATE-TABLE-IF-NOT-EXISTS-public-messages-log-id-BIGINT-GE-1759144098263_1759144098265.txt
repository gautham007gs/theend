
-- Create the messages_log table
CREATE TABLE IF NOT EXISTS public.messages_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  message_id TEXT,
  sender_type TEXT, -- 'user' or 'ai'
  chat_id TEXT,     -- e.g., 'kruthika_chat' to identify this specific chat instance
  text_content TEXT, -- Store a snippet of the message text
  has_image BOOLEAN DEFAULT FALSE
);

-- Create the daily_activity_log table
CREATE TABLE IF NOT EXISTS public.daily_activity_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_pseudo_id TEXT NOT NULL,
  activity_date DATE NOT NULL,
  chat_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT unique_user_activity_per_day_per_chat UNIQUE (user_pseudo_id, activity_date, chat_id)
);

-- Create the app_configurations table
CREATE TABLE IF NOT EXISTS public.app_configurations (
  id TEXT PRIMARY KEY,
  settings JSONB NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Enable Row Level Security (RLS) on the new tables
ALTER TABLE public.messages_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_activity_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_configurations ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist (to prevent duplicate errors)
DROP POLICY IF EXISTS "Allow anon inserts for message logging" ON public.messages_log;
DROP POLICY IF EXISTS "Allow anon reads for analytics" ON public.messages_log;
DROP POLICY IF EXISTS "Allow anon inserts for daily activity" ON public.daily_activity_log;
DROP POLICY IF EXISTS "Allow anon reads for DAU analytics" ON public.daily_activity_log;
DROP POLICY IF EXISTS "Allow anon reads for app configurations" ON public.app_configurations;
DROP POLICY IF EXISTS "Allow anon inserts for app configurations" ON public.app_configurations;
DROP POLICY IF EXISTS "Allow anon updates for app configurations" ON public.app_configurations;

-- Create policies that allow anonymous users to insert/read (for development)
CREATE POLICY "Allow anon inserts for message logging" ON public.messages_log
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon reads for analytics" ON public.messages_log
FOR SELECT USING (true);

CREATE POLICY "Allow anon inserts for daily activity" ON public.daily_activity_log
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon reads for DAU analytics" ON public.daily_activity_log
FOR SELECT USING (true);

CREATE POLICY "Allow anon reads for app configurations" ON public.app_configurations
FOR SELECT USING (true);

CREATE POLICY "Allow anon inserts for app configurations" ON public.app_configurations
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon updates for app configurations" ON public.app_configurations
FOR UPDATE USING (true) WITH CHECK (true);

-- Create PostgreSQL functions for analytics
CREATE OR REPLACE FUNCTION get_daily_message_counts(start_date DATE)
RETURNS TABLE(date DATE, messages BIGINT)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    DATE_TRUNC('day', ml.created_at AT TIME ZONE 'UTC')::DATE AS date,
    COUNT(ml.id) AS messages
  FROM public.messages_log ml
  WHERE (ml.created_at AT TIME ZONE 'UTC')::DATE >= start_date
  GROUP BY DATE_TRUNC('day', ml.created_at AT TIME ZONE 'UTC')
  ORDER BY date ASC;
END;
$$;

CREATE OR REPLACE FUNCTION get_daily_active_user_counts(start_date DATE)
RETURNS TABLE(date DATE, active_users BIGINT)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    dal.activity_date AS date,
    COUNT(DISTINCT dal.user_pseudo_id) AS active_users
  FROM public.daily_activity_log dal
  WHERE dal.activity_date >= start_date
  GROUP BY dal.activity_date
  ORDER BY date ASC;
END;
$$;

-- Grant execute permissions on functions to anon role
GRANT EXECUTE ON FUNCTION get_daily_message_counts(DATE) TO anon;
GRANT EXECUTE ON FUNCTION get_daily_active_user_counts(DATE) TO anon;

-- Insert initial ad settings configuration
INSERT INTO public.app_configurations (id, settings) VALUES (
  'ad_settings_kruthika_chat_v1', 
  '{
    "adsEnabledGlobally": true,
    "adsterraDirectLink": "https://www.profitablecpmnetwork.com/g8nhym4yg?key=2b71bf819cb8c5c7f8e011b7b75ea097",
    "adsterraDirectLinkEnabled": true,
    "adsterraBannerCode": "<!-- Adsterra Banner Code Placeholder -->",
    "adsterraBannerEnabled": false,
    "adsterraNativeBannerCode": "<!-- Adsterra Native Banner Code Placeholder -->",
    "adsterraNativeBannerEnabled": false,
    "adsterraSocialBarCode": "<!-- Adsterra Social Bar Code Placeholder -->",
    "adsterraSocialBarEnabled": true,
    "adsterraPopunderCode": "<!-- Adsterra Popunder Code Placeholder -->",
    "adsterraPopunderEnabled": false,
    "monetagDirectLink": "https://example.com/monetag",
    "monetagDirectLinkEnabled": false,
    "monetagBannerCode": "<!-- Monetag Banner Code Placeholder -->",
    "monetagBannerEnabled": false,
    "monetagNativeBannerCode": "<!-- Monetag Native Banner Code Placeholder -->",
    "monetagNativeBannerEnabled": false,
    "monetagSocialBarCode": "<!-- Monetag Social Bar Code Placeholder -->",
    "monetagSocialBarEnabled": false,
    "monetagPopunderCode": "<!-- Monetag Popunder Code Placeholder -->",
    "monetagPopunderEnabled": false,
    "maxDirectLinkAdsPerDay": 8,
    "maxDirectLinkAdsPerSession": 2,
    "messagesPerAdTrigger": 7,
    "inactivityAdTimeoutMs": 45000,
    "inactivityAdChance": 0.25,
    "userMediaInterstitialChance": 0.15
  }'
) ON CONFLICT (id) DO UPDATE SET 
  settings = EXCLUDED.settings,
  updated_at = NOW();


SELECT id, COUNT(*) as count FROM app_configurations GROUP BY id HAVING COUNT(*) > 1; -- If duplicates exist, keep only the most recent one DELETE FROM app_configurations a USING app_configurations b WHERE a.id = b.id AND a.updated_at < b.updated_at;"



CREATE TABLE sent_media (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  user_id TEXT NOT NULL,
  media_url TEXT NOT NULL,
  sent_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE (user_id, media_url)
);





-- Additional optimizations for your current SQL setup

-- Add indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_messages_log_created_at ON public.messages_log(created_at);
CREATE INDEX IF NOT EXISTS idx_messages_log_chat_id ON public.messages_log(chat_id);
CREATE INDEX IF NOT EXISTS idx_daily_activity_date ON public.daily_activity_log(activity_date);
CREATE INDEX IF NOT EXISTS idx_daily_activity_user_chat ON public.daily_activity_log(user_pseudo_id, chat_id);

-- Add a function to clean old data (helps manage costs)
CREATE OR REPLACE FUNCTION cleanup_old_messages(days_to_keep INTEGER DEFAULT 90)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM public.messages_log 
  WHERE created_at < NOW() - INTERVAL '1 day' * days_to_keep;
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION cleanup_old_messages(INTEGER) TO anon;

-- Add revenue tracking table for better ad analytics
CREATE TABLE IF NOT EXISTS public.ad_revenue_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL,
  ad_network TEXT NOT NULL, -- 'adsterra', 'monetag'
  ad_type TEXT NOT NULL, -- 'banner', 'native', 'social', 'popunder'
  impressions BIGINT DEFAULT 0,
  clicks BIGINT DEFAULT 0,
  estimated_revenue DECIMAL(10,4) DEFAULT 0,
  cpm DECIMAL(8,4) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT unique_daily_ad_stats UNIQUE (date, ad_network, ad_type)
);

ALTER TABLE public.ad_revenue_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow anon inserts for ad revenue" ON public.ad_revenue_log
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon reads for ad revenue" ON public.ad_revenue_log
FOR SELECT USING (true);

CREATE POLICY "Allow anon updates for ad revenue" ON public.ad_revenue_log
FOR UPDATE USING (true) WITH CHECK (true);



-- Add the missing daily_analytics table that's referenced in database-optimizer.ts
CREATE TABLE IF NOT EXISTS public.daily_analytics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  date DATE NOT NULL UNIQUE,
  dau INTEGER DEFAULT 0,
  message_count INTEGER DEFAULT 0,
  error_count INTEGER DEFAULT 0,
  response_time DECIMAL(8,3) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

ALTER TABLE public.daily_analytics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow anon inserts for daily analytics" ON public.daily_analytics
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon reads for daily analytics" ON public.daily_analytics
FOR SELECT USING (true);

CREATE POLICY "Allow anon updates for daily analytics" ON public.daily_analytics
FOR UPDATE USING (true) WITH CHECK (true);

-- Add index for better performance
CREATE INDEX IF NOT EXISTS idx_daily_analytics_date ON public.daily_analytics(date);

-- Add the AI profile configuration that your app expects
INSERT INTO public.app_configurations (id, settings) VALUES (
  'ai_profile_global_v1', 
  '{
    "name": "Kruthika",
    "avatarUrl": "https://placehold.co/100x100.png/E91E63/FFFFFF?text=K",
    "status": "ðŸŒ¸ Living my best life! Lets chat! ðŸŒ¸",
    "statusStoryText": "Ask me anything! ðŸ’¬",
    "statusStoryHasUpdate": true
  }'
) ON CONFLICT (id) DO UPDATE SET 
  settings = EXCLUDED.settings,
  updated_at = NOW();

-- Add analytics configuration
INSERT INTO public.app_configurations (id, settings) VALUES (
  'analytics_config', 
  '{
    "enabled": true,
    "trackingEnabled": true,
    "realTimeUpdates": true,
    "dataRetentionDays": 90
  }'
) ON CONFLICT (id) DO UPDATE SET 
  settings = EXCLUDED.settings,
  updated_at = NOW();

-- Grant permissions on the new table
GRANT EXECUTE ON FUNCTION cleanup_old_messages(INTEGER) TO anon;






-- Create user session tracking table for better session analytics
CREATE TABLE IF NOT EXISTS public.user_sessions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  user_pseudo_id TEXT NOT NULL,
  chat_id TEXT,
  started_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  last_activity TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  ended_at TIMESTAMPTZ,
  message_count INTEGER DEFAULT 0,
  duration_seconds INTEGER DEFAULT 0,
  device_type TEXT, -- 'mobile', 'desktop', 'tablet'
  browser_type TEXT,
  location_country TEXT,
  CONSTRAINT unique_session UNIQUE (session_id)
);

ALTER TABLE public.user_sessions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow anon inserts for user sessions" ON public.user_sessions
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon reads for user sessions" ON public.user_sessions
FOR SELECT USING (true);

CREATE POLICY "Allow anon updates for user sessions" ON public.user_sessions
FOR UPDATE USING (true) WITH CHECK (true);

-- Create performance metrics table
CREATE TABLE IF NOT EXISTS public.performance_metrics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  metric_date DATE NOT NULL,
  avg_response_time DECIMAL(8,3) DEFAULT 0,
  max_response_time DECIMAL(8,3) DEFAULT 0,
  min_response_time DECIMAL(8,3) DEFAULT 0,
  error_rate DECIMAL(5,4) DEFAULT 0,
  total_requests INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT unique_performance_date UNIQUE (metric_date)
);

ALTER TABLE public.performance_metrics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow anon inserts for performance metrics" ON public.performance_metrics
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon reads for performance metrics" ON public.performance_metrics
FOR SELECT USING (true);

CREATE POLICY "Allow anon updates for performance metrics" ON public.performance_metrics
FOR UPDATE USING (true) WITH CHECK (true);

-- Create engagement metrics table
CREATE TABLE IF NOT EXISTS public.engagement_metrics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  metric_date DATE NOT NULL,
  total_conversations INTEGER DEFAULT 0,
  avg_messages_per_conversation DECIMAL(6,2) DEFAULT 0,
  bounce_rate DECIMAL(5,4) DEFAULT 0,
  retention_rate DECIMAL(5,4) DEFAULT 0,
  images_shared INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT unique_engagement_date UNIQUE (metric_date)
);

ALTER TABLE public.engagement_metrics ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow anon inserts for engagement metrics" ON public.engagement_metrics
FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow anon reads for engagement metrics" ON public.engagement_metrics
FOR SELECT USING (true);

CREATE POLICY "Allow anon updates for engagement metrics" ON public.engagement_metrics
FOR UPDATE USING (true) WITH CHECK (true);

-- Create advanced analytics functions
CREATE OR REPLACE FUNCTION get_session_analytics(start_date DATE)
RETURNS TABLE(
  date DATE,
  total_sessions BIGINT,
  avg_session_duration DECIMAL(8,2),
  bounce_rate DECIMAL(5,2)
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    DATE(us.started_at) as date,
    COUNT(us.id) as total_sessions,
    COALESCE(AVG(us.duration_seconds), 0)::DECIMAL(8,2) as avg_session_duration,
    COALESCE((COUNT(CASE WHEN us.message_count <= 1 THEN 1 END) * 100.0 / NULLIF(COUNT(us.id), 0)), 0)::DECIMAL(5,2) as bounce_rate
  FROM public.user_sessions us
  WHERE DATE(us.started_at) >= start_date
  GROUP BY DATE(us.started_at)
  ORDER BY date ASC;
END;
$$;

CREATE OR REPLACE FUNCTION get_device_analytics(start_date DATE)
RETURNS TABLE(
  device_type TEXT,
  session_count BIGINT,
  percentage DECIMAL(5,2)
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  WITH device_counts AS (
    SELECT 
      COALESCE(us.device_type, 'unknown') as device,
      COUNT(us.id) as count
    FROM public.user_sessions us
    WHERE DATE(us.started_at) >= start_date
    GROUP BY COALESCE(us.device_type, 'unknown')
  ),
  total_count AS (
    SELECT SUM(count) as total FROM device_counts
  )
  SELECT 
    dc.device as device_type,
    dc.count as session_count,
    COALESCE((dc.count * 100.0 / NULLIF(tc.total, 0)), 0)::DECIMAL(5,2) as percentage
  FROM device_counts dc
  CROSS JOIN total_count tc
  ORDER BY dc.count DESC;
END;
$$;

CREATE OR REPLACE FUNCTION get_hourly_analytics(target_date DATE)
RETURNS TABLE(
  hour INTEGER,
  message_count BIGINT,
  active_users BIGINT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    EXTRACT(hour FROM ml.created_at)::INTEGER as hour,
    COUNT(ml.id) as message_count,
    COUNT(DISTINCT ml.chat_id) as active_users
  FROM public.messages_log ml
  WHERE DATE(ml.created_at) = target_date
  GROUP BY EXTRACT(hour FROM ml.created_at)
  ORDER BY hour ASC;
END;
$$;

CREATE OR REPLACE FUNCTION get_revenue_analytics(start_date DATE)
RETURNS TABLE(
  date DATE,
  total_revenue DECIMAL(10,4),
  impressions BIGINT,
  clicks BIGINT,
  ctr DECIMAL(5,4)
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    arl.date,
    SUM(arl.estimated_revenue) as total_revenue,
    SUM(arl.impressions) as impressions,
    SUM(arl.clicks) as clicks,
    COALESCE((SUM(arl.clicks) * 100.0 / NULLIF(SUM(arl.impressions), 0)), 0)::DECIMAL(5,4) as ctr
  FROM public.ad_revenue_log arl
  WHERE arl.date >= start_date
  GROUP BY arl.date
  ORDER BY arl.date ASC;
END;
$$;

-- Grant execute permissions on new functions
GRANT EXECUTE ON FUNCTION get_session_analytics(DATE) TO anon;
GRANT EXECUTE ON FUNCTION get_device_analytics(DATE) TO anon;
GRANT EXECUTE ON FUNCTION get_hourly_analytics(DATE) TO anon;
GRANT EXECUTE ON FUNCTION get_revenue_analytics(DATE) TO anon;

-- Add indexes for better performance on new tables
CREATE INDEX IF NOT EXISTS idx_user_sessions_started_at ON public.user_sessions(started_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON public.user_sessions(user_pseudo_id);
CREATE INDEX IF NOT EXISTS idx_performance_metrics_date ON public.performance_metrics(metric_date);
CREATE INDEX IF NOT EXISTS idx_engagement_metrics_date ON public.engagement_metrics(metric_date);
CREATE INDEX IF NOT EXISTS idx_ad_revenue_date ON public.ad_revenue_log(date);

-- Insert sample data for testing (optional - remove in production)
INSERT INTO public.performance_metrics (metric_date, avg_response_time, total_requests) VALUES
(CURRENT_DATE, 1.25, 150),
(CURRENT_DATE - INTERVAL '1 day', 1.18, 142),
(CURRENT_DATE - INTERVAL '2 days', 1.32, 167);

-- Create a trigger to automatically update daily_analytics when new messages are added
CREATE OR REPLACE FUNCTION update_daily_analytics_trigger()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.daily_analytics (date, message_count)
  VALUES (DATE(NEW.created_at), 1)
  ON CONFLICT (date) 
  DO UPDATE SET 
    message_count = daily_analytics.message_count + 1,
    updated_at = NOW();
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_daily_analytics
  AFTER INSERT ON public.messages_log
  FOR EACH ROW
  EXECUTE FUNCTION update_daily_analytics_trigger();

-- Create a function to populate missing analytics data
CREATE OR REPLACE FUNCTION populate_analytics_data()
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
  processed_count INTEGER := 0;
  current_date DATE;
BEGIN
  -- Get date range from existing messages
  FOR current_date IN 
    SELECT DISTINCT DATE(created_at) 
    FROM public.messages_log 
    WHERE DATE(created_at) >= CURRENT_DATE - INTERVAL '30 days'
    ORDER BY DATE(created_at)
  LOOP
    -- Insert/update daily analytics
    INSERT INTO public.daily_analytics (date, message_count, dau)
    SELECT 
      current_date,
      COUNT(ml.id),
      COUNT(DISTINCT dal.user_pseudo_id)
    FROM public.messages_log ml
    LEFT JOIN public.daily_activity_log dal ON dal.activity_date = current_date
    WHERE DATE(ml.created_at) = current_date
    ON CONFLICT (date) 
    DO UPDATE SET 
      message_count = EXCLUDED.message_count,
      dau = EXCLUDED.dau,
      updated_at = NOW();
    
    processed_count := processed_count + 1;
  END LOOP;
  
  RETURN processed_count;
END;
$$;

GRANT EXECUTE ON FUNCTION populate_analytics_data() TO anon;

-- Run the function to populate existing data
SELECT populate_analytics_data();







-- Additional tables for real analytics tracking
-- Run this in your Supabase SQL editor

-- User sessions table for real session tracking
CREATE TABLE IF NOT EXISTS public.user_sessions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT UNIQUE NOT NULL,
  user_pseudo_id TEXT NOT NULL,
  started_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  ended_at TIMESTAMPTZ,
  duration_seconds INTEGER,
  page_views INTEGER DEFAULT 0,
  messages_sent INTEGER DEFAULT 0,
  device_type TEXT,
  browser TEXT,
  country_code TEXT,
  timezone TEXT,
  referrer TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Page views table for real page tracking
CREATE TABLE IF NOT EXISTS public.page_views (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  page_path TEXT NOT NULL,
  page_title TEXT,
  viewed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  time_on_page INTEGER, -- seconds
  referrer TEXT,
  user_agent TEXT
);

-- Real ad interactions table
CREATE TABLE IF NOT EXISTS public.ad_interactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  ad_type TEXT NOT NULL, -- 'banner', 'native', 'social', 'popunder', 'direct_link'
  ad_network TEXT NOT NULL, -- 'adsterra', 'monetag'
  action_type TEXT NOT NULL, -- 'view', 'click', 'close'
  page_path TEXT,
  timestamp TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  user_country TEXT,
  device_type TEXT
);

-- User device and location tracking
CREATE TABLE IF NOT EXISTS public.user_analytics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  user_pseudo_id TEXT NOT NULL,
  country_code TEXT,
  country_name TEXT,
  timezone TEXT,
  device_type TEXT, -- 'mobile', 'desktop', 'tablet'
  browser TEXT,
  os TEXT,
  screen_resolution TEXT,
  language TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT unique_session_analytics UNIQUE (session_id)
);

-- Cookie consent tracking
CREATE TABLE IF NOT EXISTS public.cookie_consents (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  necessary BOOLEAN DEFAULT TRUE,
  analytics BOOLEAN DEFAULT FALSE,
  advertising BOOLEAN DEFAULT FALSE,
  personalization BOOLEAN DEFAULT FALSE,
  ai_learning BOOLEAN DEFAULT FALSE,
  intimacy_level BOOLEAN DEFAULT FALSE,
  timestamp TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- User journey funnel tracking
CREATE TABLE IF NOT EXISTS public.user_journey_steps (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  step_name TEXT NOT NULL, -- 'landing', 'chat_started', 'message_sent', 'image_shared', 'long_session', 'return_visit'
  step_order INTEGER,
  completed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  page_path TEXT,
  additional_data JSONB
);

-- Enable RLS on all tables
ALTER TABLE public.user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.page_views ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ad_interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cookie_consents ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_journey_steps ENABLE ROW LEVEL SECURITY;

-- Create policies for anonymous access (adjust for production)
CREATE POLICY "Allow anon access to user_sessions" ON public.user_sessions FOR ALL USING (true);
CREATE POLICY "Allow anon access to page_views" ON public.page_views FOR ALL USING (true);
CREATE POLICY "Allow anon access to ad_interactions" ON public.ad_interactions FOR ALL USING (true);
CREATE POLICY "Allow anon access to user_analytics" ON public.user_analytics FOR ALL USING (true);
CREATE POLICY "Allow anon access to cookie_consents" ON public.cookie_consents FOR ALL USING (true);
CREATE POLICY "Allow anon access to user_journey_steps" ON public.user_journey_steps FOR ALL USING (true);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_sessions_session_id ON public.user_sessions(session_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_started_at ON public.user_sessions(started_at);
CREATE INDEX IF NOT EXISTS idx_page_views_session_id ON public.page_views(session_id);
CREATE INDEX IF NOT EXISTS idx_page_views_viewed_at ON public.page_views(viewed_at);
CREATE INDEX IF NOT EXISTS idx_ad_interactions_timestamp ON public.ad_interactions(timestamp);
CREATE INDEX IF NOT EXISTS idx_user_analytics_session_id ON public.user_analytics(session_id);
CREATE INDEX IF NOT EXISTS idx_cookie_consents_timestamp ON public.cookie_consents(timestamp);
CREATE INDEX IF NOT EXISTS idx_user_journey_session_id ON public.user_journey_steps(session_id);




-- Run this in your Supabase SQL editor
-- Function to increment message count in user sessions

CREATE OR REPLACE FUNCTION increment_session_messages(session_id_param TEXT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE public.user_sessions 
  SET messages_sent = COALESCE(messages_sent, 0) + 1
  WHERE session_id = session_id_param;
  
  -- If no session exists, this won't do anything (which is fine)
END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION increment_session_messages(TEXT) TO anon;










-- Additional tables for real analytics tracking
-- Run this in your Supabase SQL editor

-- First, add the missing columns to existing tables
ALTER TABLE public.messages_log 
ADD COLUMN IF NOT EXISTS has_image BOOLEAN DEFAULT FALSE;

ALTER TABLE public.user_sessions 
ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT TRUE,
ADD COLUMN IF NOT EXISTS messages_sent INTEGER DEFAULT 0;

-- Create missing tables if they don't exist
CREATE TABLE IF NOT EXISTS public.messages_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  message_id TEXT UNIQUE NOT NULL,
  sender_type TEXT NOT NULL CHECK (sender_type IN ('user', 'ai')),
  chat_id TEXT NOT NULL DEFAULT 'kruthika_chat',
  text_content TEXT,
  has_image BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.daily_activity_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  activity_date DATE NOT NULL,
  user_pseudo_id TEXT NOT NULL,
  activity_type TEXT DEFAULT 'active',
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT unique_daily_user UNIQUE (activity_date, user_pseudo_id)
);

-- User sessions table for real session tracking
CREATE TABLE IF NOT EXISTS public.user_sessions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT UNIQUE NOT NULL,
  user_pseudo_id TEXT NOT NULL,
  started_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  ended_at TIMESTAMPTZ,
  duration_seconds INTEGER,
  page_views INTEGER DEFAULT 0,
  messages_sent INTEGER DEFAULT 0,
  device_type TEXT,
  browser TEXT,
  country_code TEXT,
  timezone TEXT,
  referrer TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Page views table for real page tracking
CREATE TABLE IF NOT EXISTS public.page_views (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  page_path TEXT NOT NULL,
  page_title TEXT,
  viewed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  time_on_page INTEGER, -- seconds
  referrer TEXT,
  user_agent TEXT
);

-- Real ad interactions table
CREATE TABLE IF NOT EXISTS public.ad_interactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  ad_type TEXT NOT NULL, -- 'banner', 'native', 'social', 'popunder', 'direct_link'
  ad_network TEXT NOT NULL, -- 'adsterra', 'monetag'
  action_type TEXT NOT NULL, -- 'view', 'click', 'close'
  page_path TEXT,
  timestamp TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  user_country TEXT,
  device_type TEXT
);

-- User device and location tracking
CREATE TABLE IF NOT EXISTS public.user_analytics (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  user_pseudo_id TEXT NOT NULL,
  country_code TEXT,
  country_name TEXT,
  timezone TEXT,
  device_type TEXT, -- 'mobile', 'desktop', 'tablet'
  browser TEXT,
  os TEXT,
  screen_resolution TEXT,
  language TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  CONSTRAINT unique_session_analytics UNIQUE (session_id)
);

-- Cookie consent tracking
CREATE TABLE IF NOT EXISTS public.cookie_consents (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  necessary BOOLEAN DEFAULT TRUE,
  analytics BOOLEAN DEFAULT FALSE,
  advertising BOOLEAN DEFAULT FALSE,
  personalization BOOLEAN DEFAULT FALSE,
  ai_learning BOOLEAN DEFAULT FALSE,
  intimacy_level BOOLEAN DEFAULT FALSE,
  timestamp TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- User journey funnel tracking
CREATE TABLE IF NOT EXISTS public.user_journey_steps (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id TEXT NOT NULL,
  step_name TEXT NOT NULL, -- 'landing', 'chat_started', 'message_sent', 'image_shared', 'long_session', 'return_visit'
  step_order INTEGER,
  completed_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  page_path TEXT,
  additional_data JSONB
);

-- Create function to increment session messages
CREATE OR REPLACE FUNCTION increment_session_messages(session_id_param TEXT)
RETURNS void AS $$
BEGIN
  UPDATE public.user_sessions 
  SET messages_sent = COALESCE(messages_sent, 0) + 1
  WHERE session_id = session_id_param;
END;
$$ LANGUAGE plpgsql;

-- Enable RLS on all tables
ALTER TABLE public.messages_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_activity_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.page_views ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ad_interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cookie_consents ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_journey_steps ENABLE ROW LEVEL SECURITY;

-- Create policies for anonymous access (adjust for production)
DROP POLICY IF EXISTS "Allow anon access to messages_log" ON public.messages_log;
DROP POLICY IF EXISTS "Allow anon access to daily_activity_log" ON public.daily_activity_log;
DROP POLICY IF EXISTS "Allow anon access to user_sessions" ON public.user_sessions;
DROP POLICY IF EXISTS "Allow anon access to page_views" ON public.page_views;
DROP POLICY IF EXISTS "Allow anon access to ad_interactions" ON public.ad_interactions;
DROP POLICY IF EXISTS "Allow anon access to user_analytics" ON public.user_analytics;
DROP POLICY IF EXISTS "Allow anon access to cookie_consents" ON public.cookie_consents;
DROP POLICY IF EXISTS "Allow anon access to user_journey_steps" ON public.user_journey_steps;

CREATE POLICY "Allow anon access to messages_log" ON public.messages_log FOR ALL USING (true);
CREATE POLICY "Allow anon access to daily_activity_log" ON public.daily_activity_log FOR ALL USING (true);
CREATE POLICY "Allow anon access to user_sessions" ON public.user_sessions FOR ALL USING (true);
CREATE POLICY "Allow anon access to page_views" ON public.page_views FOR ALL USING (true);
CREATE POLICY "Allow anon access to ad_interactions" ON public.ad_interactions FOR ALL USING (true);
CREATE POLICY "Allow anon access to user_analytics" ON public.user_analytics FOR ALL USING (true);
CREATE POLICY "Allow anon access to cookie_consents" ON public.cookie_consents FOR ALL USING (true);
CREATE POLICY "Allow anon access to user_journey_steps" ON public.user_journey_steps FOR ALL USING (true);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_messages_log_created_at ON public.messages_log(created_at);
CREATE INDEX IF NOT EXISTS idx_messages_log_sender_type ON public.messages_log(sender_type);
CREATE INDEX IF NOT EXISTS idx_daily_activity_date ON public.daily_activity_log(activity_date);
CREATE INDEX IF NOT EXISTS idx_user_sessions_session_id ON public.user_sessions(session_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_started_at ON public.user_sessions(started_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_is_active ON public.user_sessions(is_active);
CREATE INDEX IF NOT EXISTS idx_page_views_session_id ON public.page_views(session_id);
CREATE INDEX IF NOT EXISTS idx_page_views_viewed_at ON public.page_views(viewed_at);
CREATE INDEX IF NOT EXISTS idx_ad_interactions_timestamp ON public.ad_interactions(timestamp);
CREATE INDEX IF NOT EXISTS idx_user_analytics_session_id ON public.user_analytics(session_id);
CREATE INDEX IF NOT EXISTS idx_cookie_consents_timestamp ON public.cookie_consents(timestamp);
CREATE INDEX IF NOT EXISTS idx_user_journey_session_id ON public.user_journey_steps(session_id);
